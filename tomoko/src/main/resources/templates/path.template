<@pp.dropOutputFile />
<#list config.prefixes as prefix>
<@pp.changeOutputFile name=prefix.name+"Path.java" />
<#assign parameters = (prefix.size > 0)>
<#assign genericList><#if parameters><#list 1..prefix.size as index>${config.generics[index-1].code}<#sep>, </#list></#if></#assign>
package io.qubite.tomoko.specification.dsl;

<#if !prefix?is_first>
import ${prefix.removeConsumer.fullName};
</#if>
import io.qubite.tomoko.path.PathTemplate;
import io.qubite.tomoko.path.node.PathNodes;
import io.qubite.tomoko.path.node.ValueNode;
import io.qubite.tomoko.path.node.ValuelessNode;
import io.qubite.tomoko.specification.TreeSpecificationBuilder;
import io.qubite.tomoko.type.SimpleType;
import io.qubite.tomoko.type.Types;
import net.jodah.typetools.TypeResolver;

import ${prefix.consumer.fullName};

/**
 * Ongoing path definition. Used to specify path static structure together with path parameters.
 *
<#if parameters><#list 1..prefix.size as index>
 * @param <${config.generics[index-1].code}> type of the ${config.generics[index-1].parameter} path parameter
</#list></#if>
 */
public class ${prefix.name}Path<#if parameters><<#list 1..prefix.size as index>${config.generics[index-1].code}<#sep>, </#list>></#if> {

    private final TreeSpecificationBuilder builder;
    <#if parameters><#list 1..prefix.size as index>
    private final PathTemplate<${config.generics[index-1].code}> ${config.generics[index-1].parameter}ArgumentPath;
    </#list></#if>
    private final PathTemplate<?> path;

    ${prefix.name}Path(TreeSpecificationBuilder builder, <#if parameters><#list 1..prefix.size as index>PathTemplate<${config.generics[index-1].code}> ${config.generics[index-1].parameter}ArgumentPath, </#list></#if>PathTemplate<?> path) {
        this.builder = builder;
        <#if parameters><#list 1..prefix.size as index>
        this.${config.generics[index-1].parameter}ArgumentPath = ${config.generics[index-1].parameter}ArgumentPath;
        </#list></#if>
        this.path = path;
    }
    /**
     * Adds a valueless node to the path as described by the provided object.<br/><br/>
     * Should be used only if other DSL methods do not support the desired scenario.
     *
     * @param node
     * @return
     */
    public ${prefix.name}Path<#if parameters><${genericList}></#if> node(ValuelessNode node) {
        return new ${prefix.name}Path(builder, <#if parameters><#list 1..prefix.size as index>${config.generics[index-1].parameter}ArgumentPath, </#list></#if>path.then(node));
    }

<#if prefix?has_next>
    <#assign nextCode = config.generics[prefix?index].code>
    <#assign nextPrefix = config.prefixes[prefix?index+1]>
    /**
     * Adds a parameter to the path as described by the provided object.<br/><br/>
     * Should be used only if other DSL methods do not support the desired scenario.
     *
     * @param node
     * @param <${nextCode}> new path parameter type
     * @return
     */
    public <${nextCode}> ${config.prefixes[prefix?index+1].name}Path<${genericList}<#if parameters>, </#if>${nextCode}> node(ValueNode<${nextCode}> node) {
        PathTemplate<${nextCode}> argPath = path.then(node);
        return new ${nextPrefix.name}Path(builder, <#if parameters><#list 1..prefix.size as index>${config.generics[index-1].parameter}ArgumentPath, </#list></#if>argPath, argPath);
    }

    /**
     * Adds a string parameter to the path.
     *
     * @return
     */
    public ${nextPrefix.name}Path<${genericList}<#if parameters>, </#if>String> string() {
        return node(PathNodes.textNode());
    }

    /**
     * Adds an integer parameter to the path.
     *
     * @return
     */
    public ${nextPrefix.name}Path<${genericList}<#if parameters>, </#if>Integer> integer() {
        return node(PathNodes.integerNode());
    }

    /**
     * Adds an integer parameter restricted by minimal and maximal values to the path.
     *
     * @param min minimal (inclusive) value accepted as a value of this parameter
     * @param max maximal (inclusive) value accepted as a value of this parameter
     * @return
     */
    public ${nextPrefix.name}Path<${genericList}<#if parameters>, </#if>Integer> integer(int min, int max) {
        return node(PathNodes.integerNode(min, max));
    }

    /**
     * Adds an integer parameter restricted by minimal value to the path.
     *
     * @param min minimal (inclusive) value accepted as a value of this parameter
     * @return
     */
    public ${nextPrefix.name}Path<${genericList}<#if parameters>, </#if>Integer> minInteger(int min) {
        return node(PathNodes.minIntegerNode(min));
    }

    /**
     * Adds an integer parameter restricted by maximal value to the path.
     *
     * @param max maximal (inclusive) value accepted as a value of this parameter
     * @return
     */
    public ${nextPrefix.name}Path<${genericList}<#if parameters>, </#if>Integer> maxInteger(int max) {
        return node(PathNodes.maxIntegerNode(max));
    }

    /**
     * Adds a long parameter to the path.
     *
     * @return
     */
    public ${nextPrefix.name}Path<${genericList}<#if parameters>, </#if>Long> longParameter() {
        return node(PathNodes.longNode());
    }

    /**
     * Adds a string parameter restricted by a regular expression to the path.
     *
     * @return
     */
    public ${nextPrefix.name}Path<${genericList}<#if parameters>, </#if>String> regex(String regex) {
        return node(PathNodes.regexNode(regex));
    }

    /**
     * Adds a string parameter interpreted as an encoded URL to the path.
     *
     * @return
     */
    public ${nextPrefix.name}Path<${genericList}<#if parameters>, </#if>String> urlEncoded() {
        return node(PathNodes.urlEncodedNode());
    }

</#if>
    /**
     * Adds a static string to the path e.g. "author/firstName".<br/><br/>
     * Splits the parameter into separate tokens by the "/" character and adds each token as a separate node.
     * The "/" character is prohibited at the start and at the end of the provided parameter.
     *
     * @param text
     * @return
     */
    public ${prefix.name}Path<#if parameters><${genericList}></#if> node(String text) {
        String[] nodes = text.split("/", -1);
        ${prefix.name}Path<#if parameters><${genericList}></#if> result = this;
        for (String node : nodes) {
            if (node.isEmpty()) {
                throw new IllegalArgumentException("Path node name cannot be empty");
            }
            result = node(PathNodes.staticNode(node));
        }
        return result;
    }

    /**
     * Adds the end index static token ("-") to the path.
     *
     * @return
     */
    public ${prefix.name}TypeSpec<#if parameters><${genericList}></#if> endIndex() {
        return new ${prefix.name}TypeSpec(builder, <#if parameters><#list 1..prefix.size as index>${config.generics[index-1].parameter}ArgumentPath, </#list></#if>path.then(PathNodes.endIndexNode()));
    }

    /**
     * Completes the path template definition and allows to directly specify the type of the value object.
     *
     * @return
     */
    public ${prefix.name}TypeSpec<#if parameters><${genericList}></#if> value() {
        return new ${prefix.name}TypeSpec(builder, <#if parameters><#list 1..prefix.size as index>${config.generics[index-1].parameter}ArgumentPath, </#list></#if>path);
    }

    /**
     * Completes the path template definition and registers a handler for the ADD operation.<br/><br/>
     * Value type is inferred from the handler's signature. Sometimes it is impossible e.g. when the handler is a mock or the type is generic.
     * In that case the type should be specified through the value() method.
     *
     * @param consumer
     * @param <V> value object type
     * @return descriptor of the registered handler
     */
    public <V> ${prefix.name}AddDescriptor<${genericList}<#if parameters>, </#if>V> handleAdd(${prefix.consumer.name}<${genericList}<#if parameters>, </#if>V> consumer) {
        return handleAdd(path, consumer);
    }

    /**
     * Completes the path template definition and registers a handler for the REMOVE operation.
     *
     * @param consumer
     * @param <V> value object type
     * @return descriptor of the registered handler
     */
    public ${prefix.name}RemoveDescriptor<#if parameters><${genericList}></#if> handleRemove(${prefix.removeConsumer.name}<#if parameters><${genericList}></#if> consumer) {
        builder.handleRemove(path, <#if parameters><#list 1..prefix.size as index>${config.generics[index-1].parameter}ArgumentPath, </#list></#if>consumer);
        return new ${prefix.name}RemoveDescriptor(<#if parameters><#list 1..prefix.size as index>${config.generics[index-1].parameter}ArgumentPath, </#list></#if>path);
    }

    /**
     * Completes the path template definition and registers a handler for the REPLACE operation.<br/><br/>
     * Value type is inferred from the handler's signature. Sometimes it is impossible e.g. when the handler is a mock or the type is generic.
     * In that case the type should be specified through the value() method.
     *
     * @param handler
     * @param <V> value object type
     * @return descriptor of the registered handler
     */
    public <V> ${prefix.name}ReplaceDescriptor<${genericList}<#if parameters>, </#if>V> handleReplace(${prefix.consumer.name}<${genericList}<#if parameters>, </#if>V> consumer) {
        SimpleType<V> type = TypeExtractor.extractSimpleType(consumer);
        builder.handleReplace(path, type, <#if parameters><#list 1..prefix.size as index>${config.generics[index-1].parameter}ArgumentPath, </#list></#if>consumer);
        return new ${prefix.name}ReplaceDescriptor(path, <#if parameters><#list 1..prefix.size as index>${config.generics[index-1].parameter}ArgumentPath, </#list></#if>type);
    }

    private <V> ${prefix.name}AddDescriptor<${genericList}<#if parameters>, </#if>V> handleAdd(PathTemplate<?> path, ${prefix.consumer.name}<${genericList}<#if parameters>, </#if>V> consumer) {
        SimpleType<V> type = TypeExtractor.extractSimpleType(consumer);
        builder.handleAdd(path, type, <#if parameters><#list 1..prefix.size as index>${config.generics[index-1].parameter}ArgumentPath, </#list></#if>consumer);
        return new ${prefix.name}AddDescriptor(path, <#if parameters><#list 1..prefix.size as index>${config.generics[index-1].parameter}ArgumentPath, </#list></#if>type);
    }

}
</#list>
