<@pp.dropOutputFile />
<#list config.prefixes as prefix>
<@pp.changeOutputFile name=prefix.name+"Path.java" />
<#assign parameters = (prefix.size > 0)>
<#assign genericList><#if parameters><#list 1..prefix.size as index>${config.generics[index-1].code}<#sep>, </#list></#if></#assign>
package io.qubite.tomoko.specification.dsl;

<#if !prefix?is_first>
import ${prefix.removeConsumer.fullName};
</#if>
import io.qubite.tomoko.path.PathTemplate;
import io.qubite.tomoko.path.node.PathNodes;
import io.qubite.tomoko.path.node.ValueNode;
import io.qubite.tomoko.path.node.ValuelessNode;
import io.qubite.tomoko.specification.TreeSpecificationBuilder;
import io.qubite.tomoko.type.SimpleType;
import io.qubite.tomoko.type.Types;
import net.jodah.typetools.TypeResolver;

import ${prefix.consumer.fullName};

public class ${prefix.name}Path<#if parameters><<#list 1..prefix.size as index>${config.generics[index-1].code}<#sep>, </#list>></#if> {

    private final TreeSpecificationBuilder builder;
    <#if parameters><#list 1..prefix.size as index>
    private final PathTemplate<${config.generics[index-1].code}> ${config.generics[index-1].parameter}ArgumentPath;
    </#list></#if>
    private final PathTemplate<?> path;

    ${prefix.name}Path(TreeSpecificationBuilder builder, <#if parameters><#list 1..prefix.size as index>PathTemplate<${config.generics[index-1].code}> ${config.generics[index-1].parameter}ArgumentPath, </#list></#if>PathTemplate<?> path) {
        this.builder = builder;
        <#if parameters><#list 1..prefix.size as index>
        this.${config.generics[index-1].parameter}ArgumentPath = ${config.generics[index-1].parameter}ArgumentPath;
        </#list></#if>
        this.path = path;
    }

    public ${prefix.name}Path<#if parameters><${genericList}></#if> path(ValuelessNode node) {
        return new ${prefix.name}Path(builder, <#if parameters><#list 1..prefix.size as index>${config.generics[index-1].parameter}ArgumentPath, </#list></#if>path.then(node));
    }

<#if prefix?has_next>
    <#assign nextCode = config.generics[prefix?index].code>
    <#assign nextPrefix = config.prefixes[prefix?index+1]>
    public <${nextCode}> ${config.prefixes[prefix?index+1].name}Path<${genericList}<#if parameters>, </#if>${nextCode}> path(ValueNode<${nextCode}> node) {
        PathTemplate<${nextCode}> argPath = path.then(node);
        return new ${nextPrefix.name}Path(builder, <#if parameters><#list 1..prefix.size as index>${config.generics[index-1].parameter}ArgumentPath, </#list></#if>argPath, argPath);
    }

    public ${nextPrefix.name}Path<${genericList}<#if parameters>, </#if>String> string() {
        return path(PathNodes.textNode());
    }

    public ${nextPrefix.name}Path<${genericList}<#if parameters>, </#if>Integer> integer() {
        return path(PathNodes.integerNode());
    }

    public ${nextPrefix.name}Path<${genericList}<#if parameters>, </#if>Integer> integer(int min, int max) {
        return path(PathNodes.integerNode(min, max));
    }

    public ${nextPrefix.name}Path<${genericList}<#if parameters>, </#if>Integer> minInteger(int min) {
        return path(PathNodes.minIntegerNode(min));
    }

    public ${nextPrefix.name}Path<${genericList}<#if parameters>, </#if>Integer> maxInteger(int max) {
        return path(PathNodes.maxIntegerNode(max));
    }

    public ${nextPrefix.name}Path<${genericList}<#if parameters>, </#if>Long> longParameter() {
        return path(PathNodes.longNode());
    }

    public ${nextPrefix.name}Path<${genericList}<#if parameters>, </#if>String> regex(String regex) {
        return path(PathNodes.regexNode(regex));
    }

    public ${nextPrefix.name}Path<${genericList}<#if parameters>, </#if>String> urlEncoded() {
        return path(PathNodes.urlEncodedNode());
    }

</#if>
    public ${prefix.name}Path<#if parameters><${genericList}></#if> path(String text) {
        String[] nodes = text.split("/", -1);
        ${prefix.name}Path<#if parameters><${genericList}></#if> result = this;
        for (String node : nodes) {
            if (node.isEmpty()) {
                throw new IllegalArgumentException("Path node name cannot be empty");
            }
            result = path(PathNodes.staticNode(node));
        }
        return result;
    }

    public ${prefix.name}TypeSpec<#if parameters><${genericList}></#if> endIndex() {
        return new ${prefix.name}TypeSpec(builder, <#if parameters><#list 1..prefix.size as index>${config.generics[index-1].parameter}ArgumentPath, </#list></#if>path.then(PathNodes.endIndexNode()));
    }

    public ${prefix.name}TypeSpec<#if parameters><${genericList}></#if> handleAdd() {
        return new ${prefix.name}TypeSpec(builder, <#if parameters><#list 1..prefix.size as index>${config.generics[index-1].parameter}ArgumentPath, </#list></#if>path);
    }

    /**
     * Only use for simple types, not for generics i.e. collections, maps.
     *
     * @param consumer
     * @param <V>
     * @return
     */
    public <V> ${prefix.name}AddDescriptor<${genericList}<#if parameters>, </#if>V> handleAdd(${prefix.consumer.name}<${genericList}<#if parameters>, </#if>V> consumer) {
        return handleAdd(path, consumer);
    }

    public <V> ${prefix.name}AddDescriptor<${genericList}<#if parameters>, </#if>V> handleEndIndex(${prefix.consumer.name}<${genericList}<#if parameters>, </#if>V> consumer) {
        return handleAdd(path.then(PathNodes.endIndexNode()), consumer);
    }

    public ${prefix.name}RemoveDescriptor<#if parameters><${genericList}></#if> handleRemove(${prefix.removeConsumer.name}<#if parameters><${genericList}></#if> consumer) {
        builder.handleRemove(path, <#if parameters><#list 1..prefix.size as index>${config.generics[index-1].parameter}ArgumentPath, </#list></#if>consumer);
        return new ${prefix.name}RemoveDescriptor(<#if parameters><#list 1..prefix.size as index>${config.generics[index-1].parameter}ArgumentPath, </#list></#if>path);
    }

    private <V> ${prefix.name}AddDescriptor<${genericList}<#if parameters>, </#if>V> handleAdd(PathTemplate<?> path, ${prefix.consumer.name}<${genericList}<#if parameters>, </#if>V> consumer) {
        Class<?>[] classes = TypeResolver.resolveRawArguments(${prefix.consumer.name}.class, consumer.getClass());
        Class<V> valueClass = (Class<V>) classes[${prefix?index}];
        DslPreconditions.checkNotUnknown(valueClass);
        DslPreconditions.checkNonGeneric(valueClass);
        SimpleType<V> type = Types.simple(valueClass);
        builder.handleAdd(path, type, <#if parameters><#list 1..prefix.size as index>${config.generics[index-1].parameter}ArgumentPath, </#list></#if>consumer);
        return new ${prefix.name}AddDescriptor(path, <#if parameters><#list 1..prefix.size as index>${config.generics[index-1].parameter}ArgumentPath, </#list></#if>type);
    }

}
</#list>
