<@pp.dropOutputFile />
<#list config.prefixes as prefix>
<@pp.changeOutputFile name=prefix.name+"TypeSpec.java" />
<#assign parameters = (prefix.size > 0)>
package io.qubite.tomoko.specification.dsl;

import io.qubite.tomoko.path.PathTemplate;
import io.qubite.tomoko.specification.TreeSpecificationBuilder;
import io.qubite.tomoko.type.SimpleType;
import io.qubite.tomoko.type.Types;
import io.qubite.tomoko.type.ValueType;

import ${prefix.consumer.fullName};

import java.util.List;
import java.util.Map;

/**
 * Holds full information about the path and the path parameters. Used to specify the type of the value object consumed by a handler.
 *
<#if parameters><#list 1..prefix.size as index>
 * @param <${config.generics[index-1].code}> ${config.generics[index-1].parameter} path parameter type
</#list></#if>
 */
public class ${prefix.name}TypeSpec<#if parameters><<#list 1..prefix.size as index>${config.generics[index-1].code}<#sep>, </#list>></#if> {

    private final TreeSpecificationBuilder builder;
    <#if parameters><#list 1..prefix.size as index>
    private final PathTemplate<${config.generics[index-1].code}> ${config.generics[index-1].parameter}ArgumentPath;
    </#list></#if>
    private final PathTemplate<?> path;

    ${prefix.name}TypeSpec(TreeSpecificationBuilder builder, <#if parameters><#list 1..prefix.size as index>PathTemplate<${config.generics[index-1].code}> ${config.generics[index-1].parameter}ArgumentPath, </#list></#if>PathTemplate<?> path) {
        this.builder = builder;
        <#if parameters><#list 1..prefix.size as index>
        this.${config.generics[index-1].parameter}ArgumentPath = ${config.generics[index-1].parameter}ArgumentPath;
        </#list></#if>
        this.path = path;
    }

    /**
     * Registers a handler for the ADD operation.<br/><br/>
     * Value type is inferred from the handler's signature. Sometimes it is impossible e.g. when the handler is a mock or the type is generic.
     * In that case the type should be specified directly using other methods found in this class.
     *
     * @param handler
     * @param <V> value object type
     * @return descriptor of the registered handler
     */
    public <V> ${prefix.name}AddDescriptor<<#if parameters><#list 1..prefix.size as index>${config.generics[index-1].code}, </#list></#if>V> handleAdd(${prefix.consumer.name}<<#if parameters><#list 1..prefix.size as index>${config.generics[index-1].code}, </#list></#if>V> handler) {
        SimpleType<V> valueType = TypeExtractor.extractSimpleType(handler);
        builder.handleAdd(path, valueType, <#if parameters><#list 1..prefix.size as index>${config.generics[index-1].parameter}ArgumentPath, </#list></#if>handler);
        return new ${prefix.name}AddDescriptor(path, <#if parameters><#list 1..prefix.size as index>${config.generics[index-1].parameter}ArgumentPath, </#list></#if>valueType);
    }

    /**
     * Registers a handler for the REPLACE operation.<br/><br/>
     * Value type is inferred from the handler's signature. Sometimes it is impossible e.g. when the handler is a mock or the type is generic.
     * In that case the type should be specified directly using other methods found in this class.
     *
     * @param handler
     * @param <V> value object type
     * @return descriptor of the registered handler
     */
    public <V> ${prefix.name}ReplaceDescriptor<<#if parameters><#list 1..prefix.size as index>${config.generics[index-1].code}, </#list></#if>V> handleReplace(${prefix.consumer.name}<<#if parameters><#list 1..prefix.size as index>${config.generics[index-1].code}, </#list></#if>V> handler) {
        SimpleType<V> valueType = TypeExtractor.extractSimpleType(handler);
        builder.handleReplace(path, valueType, <#if parameters><#list 1..prefix.size as index>${config.generics[index-1].parameter}ArgumentPath, </#list></#if>handler);
        return new ${prefix.name}ReplaceDescriptor(path, <#if parameters><#list 1..prefix.size as index>${config.generics[index-1].parameter}ArgumentPath, </#list></#if>valueType);
    }

    /**
     * Sets the provided type descriptor as the type of the value object.<br/><br/>
     * To be used for custom types not supported by other DSL methods.
     *
     * @param valueType
     * @param <V>
     * @return
     */
    public <V> ${prefix.name}HandlerSpec<<#if parameters><#list 1..prefix.size as index>${config.generics[index-1].code}, </#list></#if>V> type(ValueType<V> valueType) {
        return new ${prefix.name}HandlerSpec(builder, <#if parameters><#list 1..prefix.size as index>${config.generics[index-1].parameter}ArgumentPath, </#list></#if>path, valueType);
    }

    /**
     * Sets the argument as the type of the value object.
     *
     * @param valueClass non generic class representing the type of the value object.
     * @param <V>
     * @return
     */
    public <V> ${prefix.name}HandlerSpec<<#if parameters><#list 1..prefix.size as index>${config.generics[index-1].code}, </#list></#if>V> type(Class<V> valueClass) {
        return type(Types.simple(valueClass));
    }

    /**
     * Sets String as the type of the value object. Shorthand for type(String.class).
     *
     * @return
     */
    public ${prefix.name}HandlerSpec<<#if parameters><#list 1..prefix.size as index>${config.generics[index-1].code}, </#list></#if>String> string() {
        return type(Types.string());
    }

    /**
     * Sets Integer as the type of the value object. Shorthand for type(Integer.class).
     *
     * @return
     */
    public ${prefix.name}HandlerSpec<<#if parameters><#list 1..prefix.size as index>${config.generics[index-1].code}, </#list></#if>Integer> integer() {
        return type(Types.integer());
    }

    /**
     * Sets Boolean as the type of the value object. Shorthand for type(Boolean.class).
     *
     * @return
     */
    public ${prefix.name}HandlerSpec<<#if parameters><#list 1..prefix.size as index>${config.generics[index-1].code}, </#list></#if>Boolean> bool() {
        return type(Types.booleanValue());
    }

    /**
     * Sets Double as the type of the value object. Shorthand for type(Double.class).
     *
     * @return
     */
    public ${prefix.name}HandlerSpec<<#if parameters><#list 1..prefix.size as index>${config.generics[index-1].code}, </#list></#if>Double> number() {
        return type(Types.doubleValue());
    }

    /**
     * Sets List<E> as the type of the value object.
     *
     * @param elementClass
     * @param <E> list element type
     * @return
     */
    public <E> ${prefix.name}HandlerSpec<<#if parameters><#list 1..prefix.size as index>${config.generics[index-1].code}, </#list></#if>List<E>> list(Class<E> elementClass) {
        return type(Types.list(elementClass));
    }

    /**
     * Sets L<E> as the type of the value object.
     *
     * @param listClass represents list type, must implement the List interface and contain exactly one generic type parameter
     * @param elementClass
     * @param <L> list type
     * @param <E> list element type
     * @return
     */
    public <L extends List<E>, E> ${prefix.name}HandlerSpec<<#if parameters><#list 1..prefix.size as index>${config.generics[index-1].code}, </#list></#if>L> list(Class<L> listClass, Class<E> elementClass) {
        return type(Types.list(listClass, elementClass));
    }

    /**
     * Sets Map<K, V> as the type of the value object.
     *
     * @param keyClass
     * @param valueClass
     * @param <K> map entry key type
     * @param <V> map entry value type
     * @return
     */
    public <K, V> ${prefix.name}HandlerSpec<<#if parameters><#list 1..prefix.size as index>${config.generics[index-1].code}, </#list></#if>Map<K, V>> map(Class<K> keyClass, Class<V> valueClass) {
        return type(Types.map(keyClass, valueClass));
    }

    /**
     * Sets M<K, V> as the type of the value object.
     *
     * @param mapClass represents map type, must implement the Map interface and contain exactly two generic type parameters
     * @param keyClass
     * @param valueClass
     * @param <M> map type
     * @param <K> map entry key type
     * @param <V> map entry value type
     * @return
     */
    public <M extends Map<K, V>, K, V> ${prefix.name}HandlerSpec<<#if parameters><#list 1..prefix.size as index>${config.generics[index-1].code}, </#list></#if>M> map(Class<M> mapClass, Class<K> keyClass, Class<V> valueClass) {
        return type(Types.map(mapClass, keyClass, valueClass));
    }

}
</#list>
